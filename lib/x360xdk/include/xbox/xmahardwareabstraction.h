/*++

Copyright (C) Microsoft Corporation.  All rights reserved.

Module Name:

    XMAHardwareAbstraction.h

Abstract:

    Abstraction layer over the XMA hardware driver

--*/

#ifndef _XMAHARDWAREABSTRACTION_H_
#define _XMAHARDWAREABSTRACTION_H_

#include "XMADecoder.h"


/*
 * Structures
 */

// Playback operating structure
struct XMAPLAYBACK;
typedef XMAPLAYBACK* PXMAPLAYBACK;


// Initialization parameters
struct XMA_PLAYBACK_INIT
{
    DWORD   sampleRate;                     // 24000, 32000, 44100, or 48000
    DWORD   outputBufferSizeInSamples;      // Should be a multiple of 128.  Stereo samples actually count as two, so double the size
    BYTE    channelCount;                   // 1 or 2
    BYTE    subframesToDecode;              // 1, 2, 4, or 8.  A subframe is 128 samples.  Larger values are more efficient.

    // Note that the hardware will always operate in chunks of subframesToDecode.  So you must make sure
    // that the output buffer size is large enough for it to work and keep it sufficiently full.
    //
    // For example: if you plan to consume 384 samples per frame, you need to set subframesToDecode to
    // at least 4.  And the buffer size should be at least 7 (although 8 is better).  A buffer size of 6
    // would *not* work, because after consuming three subframes there are only three available -- so the
    // hardware won't decode anything.  It will wait until it has four subframes free.
};

// Hardware Loop setting
struct XMA_PLAYBACK_LOOP
{
    DWORD   dwLoopStartOffset;      // Bit offset of the frame where hardware should begin decoding
    DWORD   dwLoopEndOffset;        // Bit offset of the frame where hardware should end decoding
    BYTE    dwLoopSubframeEnd;      // Subframe number of loop endpoint, inclusive.  0-3.
    BYTE    dwLoopSubframeSkip;     // Number of sub-frames to skip at the loop start point.  1-4.
    BYTE    numLoops;               // 1-255.  0 means no looping, 255 is infinite.
    BYTE    RESERVED;

    // Note that if the desired loop start point is at the first subframe of a frame,
    // dwLoopStartOffset must point to the previous frame, and dwLoopSubframeSkip must
    // be set to 4 so that the correct overlap-add data can be decoded from the previous frame.
};

// Playback position information
struct XMA_PLAYBACK_POSITION
{
    void const* pCurrentData;       // The current data pointer, as submitted.  The offset can be used to determine the current packet, if desired.
    DWORD       dwPacketBitOffset;  // Current bit offset in the packet; should point to the beginning of a frame
    DWORD       dwCurrentSubframe;  // Subframe within the packet, since a frame may be partially decoded.
};


/*
 * Enumerations
 */

// Flags that can be passed to XMAPlaybackCreate
enum XMA_PLAYBACK_CREATE
{
    XMA_PLAYBACK_CREATE_DEFER_CONTEXT_ALLOCATION = 1,
    XMA_PLAYBACK_CREATE_USE_PROVIDED_MEMORY = 2,
 };

// Playback error codes generated by the hardware
enum XMA_PLAYBACK_ERROR
{
    XMA_PLAYBACK_ERROR_NONE = 0,
    XMA_PLAYBACK_ERROR_WRITE_BUFFER_INVALID = 1,
    XMA_PLAYBACK_ERROR_INSUFFICIENT_WRITE_BUFFER_SPACE = 2,
    XMA_PLAYBACK_ERROR_READ_BUFFER_INVALID = 4,
    XMA_PLAYBACK_ERROR_FRAME_CROSSES_BOUNDARY_INTO_INVALID_READ_BUFFER = 8,
    XMA_PLAYBACK_ERROR_FRAME_CROSSES_BOTH_READ_BUFFER_BOUNDARIES = 16,
};

// Parse error codes generated by the hardware
enum XMA_PLAYBACK_PARSE_ERROR
{
    XMA_PLAYBACK_PARSE_ERROR_NONE = 0,
    XMA_PLAYBACK_PARSE_ERROR_UNKNOWN_STATE = 1,
    XMA_PLAYBACK_PARSE_ERROR_OUT_OF_RANGE = 2,
    XMA_PLAYBACK_PARSE_ERROR_FRAME_SIZE_EXCEEDED = 3,
    XMA_PLAYBACK_PARSE_ERROR_BITSTREAM_CORRUPTION = 4,
    XMA_PLAYBACK_PARSE_ERROR_BARK_VLC_ERROR = 5,
    XMA_PLAYBACK_PARSE_ERROR_BARK_RLC_ERROR = 6,
    XMA_PLAYBACK_PARSE_ERROR_VLC_4D_ERROR = 7,
    XMA_PLAYBACK_PARSE_ERROR_VLC_2D_ERROR = 8,
    XMA_PLAYBACK_PARSE_ERROR_VLC_1D_ERROR = 9,
    XMA_PLAYBACK_PARSE_ERROR_RLC_0_ERROR = 10,
    XMA_PLAYBACK_PARSE_ERROR_RLC_1_ERROR = 11,
    XMA_PLAYBACK_PARSE_ERROR_LARGEVAL_24_ERROR = 15,
};


/*
 * Functions
 */

// Use default values for new parameters to avoid breaking legacy C++ code
#ifdef __cplusplus
    #define OPTARG =0
#else
    #define OPTARG
#endif

// Allocate contexts and prepare everything for playback.
// pInit represents an array, one entry for each stream.
STDAPI XMAPlaybackCreate( DWORD numStreams, XMA_PLAYBACK_INIT const* pInit, DWORD dwFlags, PXMAPLAYBACK* ppPlayback, BYTE* pMemoryBlockToUse OPTARG, DWORD dwMemoryBlockSize OPTARG );
STDAPI XMAPlaybackDestroy( PXMAPLAYBACK pPlayback );

// Calculate the size needed for a memory buffer to be passed to XMAPlaybackCreate
STDAPI_(DWORD) XMAPlaybackGetRequiredBufferSize( DWORD numStreams, XMA_PLAYBACK_INIT const* pInit );

// Allocate and free handware contexts used by a playback object
STDAPI XMAPlaybackAllocateContexts( PXMAPLAYBACK pPlayback );
STDAPI XMAPlaybackFreeContexts( PXMAPLAYBACK pPlayback );

// Check if the playback object currently has contexts associated with it
STDAPI_(BOOL) XMAPlaybackQueryContextsAllocated( PXMAPLAYBACK pPlayback );

// Disables the contexts associated with the playback in preperation for
// updating the state.  Requesting the modify-lock sets up the process,
// but does not wait for it to complete as the hardware may be actively working
// on one of the requested contexts and it is more efficient to try and do
// something else and come back later rather than wait around for it.
// When done messing around with the contexts, a resume will re-enable the contexts
// so the hardware can do some more decoding on them when it feels like it.
STDAPI XMAPlaybackRequestModifyLock( PXMAPLAYBACK pPlayback );
STDAPI_(BOOL) XMAPlaybackQueryModifyLockObtained( PXMAPLAYBACK pPlayback );
STDAPI XMAPlaybackResumePlayback( PXMAPLAYBACK pPlayback );

// A helper function that spins waiting for the modify-lock.  It will also
// timeout in the case of a hardware hang and attempt to recover the
// hardware state.  Returns S_OK normally, or S_FALSE if there was a hang condition.
STDAPI XMAPlaybackWaitUntilModifyLockObtained( PXMAPLAYBACK pPlayback );

// Submit another data packet to the context
STDAPI XMAPlaybackSubmitData( PXMAPLAYBACK pPlayback, DWORD stream, void const* pData, DWORD sizeData );

// Determine if previously submitted data is finished being decoded or is still pending.
// The pointer must match what was passed to XMAPlaybackSubmitData.
STDAPI_(BOOL) XMAPlaybackQueryInputDataPending( PXMAPLAYBACK pPlayback, DWORD stream, void const* pData );

// Check if more data may be submitted to the stream at this time
STDAPI_(BOOL) XMAPlaybackQueryReadyForMoreData( PXMAPLAYBACK pPlayback, DWORD stream );

// Query if the hardware has decoded all available data
STDAPI_(BOOL) XMAPlaybackIsIdle( PXMAPLAYBACK pPlayback, DWORD stream );

// Returns the number decoded of samples available in the output buffer
STDAPI_(DWORD) XMAPlaybackQueryAvailableData( PXMAPLAYBACK pPlayback, DWORD stream );

// Returns actual number of samples consumed, which may be less than the desired.  Fills in the pointer.
// Note that two calls may be required to consume the desired data, since it resides in a circular buffer.
STDAPI_(DWORD) XMAPlaybackConsumeDecodedData( PXMAPLAYBACK pPlayback, DWORD stream, DWORD samplesDesired, void ** pData );

// Operates similar to XMAPlaybackConsumeDecodedData, but does not mark the data as consumed.  This
// allows data to be accessed without knowing how much of it is really needed.  After the correct
// amount is determined, simply call XMAPlaybackConsumeDecodedData to update the buffer pointers.
// The value returned is the amount of contiguous data available.
STDAPI_(DWORD) XMAPlaybackAccessDecodedData( PXMAPLAYBACK pPlayback, DWORD stream, void ** pData );

// Moves the decode position back from the end by the specified number of subframes, effectively
// throwing away data at the end of the decode buffer.  numSamples should be a multiple of 128.
// Useful when you know the hardware decoded more data than you want.
STDAPI_(BOOL) XMAPlaybackRewindDecodePosition( PXMAPLAYBACK pPlayback, DWORD stream, DWORD numSamples );

// Resets the stream to an idle state with no pending input buffers.
// Any decoded but unconsumed output samples are lost.
STDAPI XMAPlaybackFlushData( PXMAPLAYBACK pPlayback, DWORD stream );

// Query the error condition
STDAPI_(DWORD) XMAPlaybackGetErrorBits( PXMAPLAYBACK pPlayback, DWORD stream );
STDAPI_(DWORD) XMAPlaybackGetParseError( PXMAPLAYBACK pPlayback, DWORD stream );


// Set the looping parameters of the specified stream.
STDAPI XMAPlaybackSetLoop( PXMAPLAYBACK pPlayback, DWORD stream, XMA_PLAYBACK_LOOP const* pLoopInfo );

// Query how many loopbacks remain
STDAPI_(DWORD) XMAPlaybackGetRemainingLoopCount( PXMAPLAYBACK pPlayback, DWORD stream );


// Returns the current position, in samples.  This value represents consumed samples, and may
// not match the current source position due to looping or seeking.
STDAPI_(DWORD) XMAPlaybackGetStreamPosition( PXMAPLAYBACK pPlayback, DWORD stream );

// Get information about the current playback position in terms of the source data.
// These values represent decoded data, not consumed data.
STDAPI XMAPlaybackQueryCurrentPosition( PXMAPLAYBACK pPlayback, DWORD stream, XMA_PLAYBACK_POSITION* pPosInfo );

// Set the new position.  Data that has been decoded but not consumed will remain in the
// buffer and should be flushed if it is not desired.  The bitOffset value should be from the current
// data pointer (can be determined by XMAPlaybackQueryCurrentPosition) and point to the beginning
// of a frame.  The value for subFrame indicates the number of 128-sample subframes to skip.
STDAPI XMAPlaybackSetDecodePosition( PXMAPLAYBACK pPlayback, DWORD stream, DWORD bitOffset, DWORD subFrame );


// The first 32-bits of each XMA packet contains information about the packet.
// Use this to extract the bit offset of the first new frame in the packet.  Returns
// the offset, or 0 if there are no seekable frames in the packet.
STDAPI_(DWORD) XMAPlaybackGetFrameOffsetFromPacketHeader( DWORD header );


// Dump the playback state to the debug console
STDAPI_(void) XMAPlaybackDebugDump( PXMAPLAYBACK pPlayback );


// Initialize the library.  Normally called from XAudioInitialize, so if you use XAudio you don't
// need to worry about this.  Otherwise, you need to call this before using any XMAPlayback functions.
STDAPI_(void) XMAPlaybackInitialize( void );


#endif  // _XMAHARDWAREABSTRACTION_H_
